<?php
/**
 *
 * Part of the QCubed PHP framework.
 *
 * @license MIT
 *
 */

namespace QCubed\Bootstrap;

use QCubed\Control\ControlBase;
use QCubed\Control\FormBase;
use QCubed\Project\Control\Paginator as PaginatorBase;
use QCubed\Exception\Caller;
use QCubed\Exception\InvalidCast;
use Exception;
use QCubed\Html;
use QCubed\Type;

/**
 * Class Paginator
 *
 * A bootstrap implementation of the QCubed paginator.
 *
 * @property bool $AddArrow whether to add arrows to the buttons
 * @property-write int $Size SMALL, MEDIUM or LARGE buttons
 *
 * @package QCubed\Bootstrap
 */
class Paginator extends PaginatorBase
{
    /** @var bool Add an arrow to the previous and next buttons */
    protected ?bool $blnAddArrow = false;
    protected string $strTag = 'nav';

    protected int $intSize = 2;

    const int SMALL = 1;
    const int MEDIUM = 2;
    const int LARGE = 3;

    /**
     * Constructor for initializing the control with a parent object and optional control ID.
     *
     * @param FormBase|ControlBase $objParent The parent object to which this control belongs.
     * @param string|null $strControlId An optional identifier for this control. If null, an ID will be autogenerated.
     *
     * @throws Caller
     */
    public function __construct(FormBase|ControlBase $objParent, ?string $strControlId = null)
    {
        parent::__construct($objParent, $strControlId);

        // Default to a very compact format.
        $this->strLabelForPrevious = '&laquo;';
        $this->strLabelForNext = '&raquo;';
    }

    /**
     * Generates the HTML for the "previous" navigation buttons in a pagination control.
     *
     * @return string The HTML string for the "previous" navigation buttons including labels, links, and disabled states.
     */
    protected function getPreviousButtonsHtml(): string
    {
        list($intPageStart, $intPageEnd) = $this->calcBunch();

        $strClasses = "";
        $strLabel = $this->strLabelForPrevious;
        if ($this->blnAddArrow) {
            $strLabel = '<span aria-hidden="true">&larr;</span> ' . $strLabel;
        }
        if ($this->intPageNumber <= 1) {
            $strButton = Html::renderTag("span", ["aria-label"=>"Previous"], $strLabel);
            $strClasses .= " disabled";
        } else {
            $this->mixActionParameter = $this->intPageNumber - 1;
            $strButton = $this->prxPagination->renderAsLink($strLabel, $this->mixActionParameter, ["aria-label"=>"Previous", 'id'=>$this->ControlId . "_arrow_" . $this->mixActionParameter], "a", false);
        }

        $strHtml = Html::renderTag("li", ["class"=>$strClasses], $strButton);

        if ($intPageStart != 1) {
            $strHtml .= $this->getPageButtonHtml(1);
            $strHtml .= Html::renderTag("li", ["class"=>'disabled'], "<span>&hellip;</span>");
        }
        return $strHtml;
    }

    /**
     * Generates the HTML string for the "Next" pagination buttons, including any necessary labels,
     * links, or disabled states, based on the current page and total page count.
     *
     * @return string HTML string representing the "Next" buttons and associated pagination elements.
     */
    protected function getNextButtonsHtml(): string
    {
        list($intPageStart, $intPageEnd) = $this->calcBunch();

        $intPageCount = $this->PageCount;
        $strClasses = "";
        $strLabel = $this->strLabelForNext;
        if ($this->blnAddArrow) {
            $strLabel = $strLabel . ' <span aria-hidden="true">&rarr;</span>' ;
        }
        if ($this->intPageNumber >= $intPageCount) {
            $strButton = Html::renderTag("span", ["aria-label"=>"Next"], $strLabel);
            $strClasses .= " disabled";
        } else {
            $this->mixActionParameter = $this->intPageNumber + 1;
            $strButton = $this->prxPagination->renderAsLink($strLabel, $this->mixActionParameter, ["aria-label"=>"Next", 'id'=>$this->ControlId . "_arrow_" . $this->mixActionParameter], "a", false);
        }

        $strHtml = Html::renderTag("li", ["class"=>$strClasses], $strButton);

        if ($intPageEnd != $intPageCount) {
            $strHtml = $this->getPageButtonHtml($intPageCount) . $strHtml;
            $strHtml = Html::renderTag("li", ["class"=>'disabled'], "<span>&hellip;</span>") . $strHtml;
        }

        return $strHtml;
    }

    /**
     * Generates the HTML for a page button based on the given page index.
     *
     * @param int $intIndex The page index for which the button HTML is to be generated.
     *
     * @return string The HTML string for the page button, either active or link-styled.
     */
    protected function getPageButtonHtml(int $intIndex): string
    {
        if ($this->intPageNumber == $intIndex) {
            $strToReturn = Html::renderTag("li", ["class"=>"active"], '<span>' . $intIndex . '<span class="sr-only">(current)</span></span>');
        } else {
            $mixActionParameter = $intIndex;
            $strToReturn = $this->prxPagination->renderAsLink($intIndex, $mixActionParameter, ['id'=>$this->ControlId . "_page_" . $mixActionParameter]);
            $strToReturn = Html::renderTag("li", [], $strToReturn);
        }
        return $strToReturn;
    }

    /**
     * Generates and returns the HTML representation of the pagination control.
     *
     * @return string The HTML string representing the complete pagination control,
     *                including previous buttons, page buttons, and next buttons,
     *                styled according to the specified size and attributes.
     * @throws Caller
     */
    public function getControlHtml(): string
    {
        $this->objPaginatedControl->dataBind();

        $strToReturn = $this->getPreviousButtonsHtml();

        list($intPageStart, $intPageEnd) = $this->calcBunch();

        for ($intIndex = $intPageStart; $intIndex <= $intPageEnd; $intIndex++) {
            $strToReturn .= $this->getPageButtonHtml($intIndex);
        }

        $strToReturn .= $this->getNextButtonsHtml();
        $strClass = "pagination";
        if ($this->intSize == self::SMALL) {
            $strClass .= " pagination-sm";
        } elseif ($this->intSize == self::LARGE) {
            $strClass .= " pagination-lg";
        }

        $strToReturn = Html::renderTag("ul", ["class"=>$strClass], $strToReturn);

        return Html::renderTag($this->strTag, $this->renderHtmlAttributes(), $strToReturn);
    }

    /**
     * Magic getter method to retrieve the value of a property by name.
     *
     * @param string $strName The name of the property to retrieve.
     *
     * @return mixed The value of the requested property.
     *
     * @throws Caller Thrown when trying to access an undefined property.
     */
    public function __get(string $strName): mixed
    {
        switch ($strName) {
            case 'AddArrow': return $this->blnAddArrow;
            default:
                try {
                    return parent::__get($strName);
                } catch (Caller $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }
        }
    }

    /**
     * Magic method for setting the value of a property dynamically.
     *
     * @param string $strName The name of the property to be set.
     * @param mixed $mixValue The value to assign to the property.
     *
     * @return void
     * @throws Caller
     * @throws InvalidCast
     * @throws Exception
     */
    public function __set(string $strName,mixed $mixValue): void
    {
        switch ($strName) {
            case 'AddArrow':
                try {
                    $this->blnAddArrow = Type::cast($mixValue, Type::BOOLEAN);
                    break;
                } catch (Caller $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }
            case 'Size':
                try {
                    $this->intSize = Type::cast($mixValue, Type::INTEGER);
                    break;
                } catch (Caller $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            default:
                try {
                    parent::__set($strName, $mixValue);
                } catch (Caller $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }
                break;
        }
    }
}
